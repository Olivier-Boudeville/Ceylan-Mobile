

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * 'mobile' service API, the Erlang parameters received from the port into
 * C variables that can be passed to the service functions, and to perform the
 * reciprocal operation on their results, so that they can be sent back to the
 * Erlang calling side.
 *
 */


// Generated by the Seaplus parse transform, based on mobile.erl:
#include "mobile_seaplus_api_mapping.h"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


// To access to the actual C implementation of the Gammu library:
#include "gammu.h"


// For exit:
#include <stdlib.h>

// For signal:
#include <signal.h>

// For memset:
#include <string.h>

// For va_start and friends:
#include <stdarg.h>



/* Apparently, when the callback set in SetSendSMSStatusCallback/3 is triggered,
   no information allows to relate a specific SMS that was sent to that callback
   (message reference is set by the carrier in the PDU that is received back).

   So, if sending a series of SMS in a row, we can only suppose that the
   callbacks triggered will be in-order (first callback corresponding to first
   SMS sent, etc.).

   Anyway, even with the dummy device, if performing two sendings in a row, the
   callback for the first will be triggered before the second is sent, so no
   problematic interleaving shall happen.

 */


/* The reference onto a SMS is supposed to be an unsigned char, but the
 * signature of the callback tells otherwise:
 *
 */
typedef int sms_tpmr ;


// Forward declarations:

void start_gammu( GSM_StateMachine * gammu_fsm ) ;

void check_gammu_error( GSM_Error error, GSM_StateMachine * gammu_fsm ) ;

void raise_gammu_error( GSM_StateMachine * gammu_fsm,
  const char * format, ... ) ;

void stop_gammu( GSM_StateMachine * gammu_fsm ) ;



// Defined and used by Seaplus:
extern FILE * log_file ;

// If wanting to enable global debugging of Gammu in Seaplus logs:
bool enable_gammu_logging = true ;

// If wanting to enable FSM-level debugging of Gammu in Seaplus logs:
bool enable_gammu_state_machine_logging = false ;


// Typically for a sending:
typedef int status ;


// UNIX signal:
typedef int signal_reported ;


volatile bool shutdown_requested = false ;


// Tells whether the last SMS sending succeeded:
volatile status sms_send_status = false ;


GSM_SMSMessage sms ;

GSM_SMSC device_smsc ;


/*
 * An interrupt-specific buffer, not to interfere with the main one that could
 * be already in use. We believe that up to one interrupt can be active at any
 * time (not multiple ones).
 *
 */
byte * interrupt_buffer = NULL ;

ETERM * interrupt_array[ 2 ] ;

ETERM * interrupt_term = NULL ;


// Poor's man pseudo-mutex:
bool interrupt_in_use = false ;


/*
 * Callback triggered by Gammu after a request to send an SMS was issued.
 *
 * Returns a relevant term to the Erlang side.
 *
 */
void sms_sending_callback( GSM_StateMachine * gammu_fsm, status send_status,
  sms_tpmr ref, void * user_data )
{

  //LOG_DEBUG( "Entering callback." ) ;

  /* Not expected to ever happen, as the (Erlang) caller is blocked, waiting
   * for an answer not sent yet.
   *
   */
  if ( interrupt_in_use )
	raise_gammu_error( gammu_fsm, "Unexpected nested interrupt" ) ;

  interrupt_in_use = true ;

  if ( send_status == 0 )
  {

	// In case of success, returning { send_success, SMSRef }:

	sms_send_status = ERR_NONE ;

	LOG_DEBUG( "Received a success notification regarding the sending of "
	  "the SMS whose reference is #%i on device %s.", ref,
	  GSM_GetConfig( gammu_fsm, -1 )->Device ) ;

	interrupt_array[0] = erl_mk_atom( "send_success" ) ;

	if ( interrupt_array[0] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create success atom term" ) ;

	interrupt_array[1] = erl_mk_int( ref ) ;

	if ( interrupt_array[1] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create reference int term" ) ;

	interrupt_term = erl_mk_tuple( interrupt_array, 2 ) ;

	if( interrupt_term == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create success pair" ) ;

	write_term( interrupt_buffer, interrupt_term ) ;

  }
  else
  {

	// In case of failure, returning { send_failure, SMSRef }:

	sms_send_status = ERR_UNKNOWN ;

	LOG_WARNING( "Received a failure notification regarding the sending of "
	  "the SMS whose reference is #%i on device %s.", ref,
	  GSM_GetConfig( gammu_fsm, -1 )->Device ) ;

	interrupt_array[0] = erl_mk_atom( "send_failure" ) ;

	if ( interrupt_array[0] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create success failure term" ) ;

	interrupt_array[1] = erl_mk_int( ref ) ;

	if ( interrupt_array[1] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create reference int term" ) ;

	interrupt_term = erl_mk_tuple( interrupt_array, 2 ) ;

	if( interrupt_term == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create failure pair" ) ;

	write_term( interrupt_buffer, interrupt_term ) ;

  }

  interrupt_in_use = false ;

  //LOG_DEBUG( "Leaving callback." ) ;

}


// Mobile-specific interrupt signal handler.
void mobile_interrupt( signal_reported sign )
{

  LOG_WARNING( "Signal #%i caught, shutting down Ceylan-Mobile.", sign ) ;

  signal( sign, SIG_IGN ) ;

  shutdown_requested = true ;

}


// No argumeter expected nor taken into account:
int main( int argc, char **argv )
{

  // Provided by the Seaplus library:
  byte * buffer = start_seaplus_driver() ;

  LOG_TRACE( "Driver started." ) ;

  // Gammu uses strings in the local encoding:
  GSM_InitLocales( NULL ) ;

  // Gammu is state-machine based:
  GSM_StateMachine * gammu_fsm = GSM_AllocStateMachine() ;

  if ( gammu_fsm == NULL )
	raise_gammu_error( gammu_fsm, "Unable to allocate Gammu state machine." ) ;

  // Pre-allocations:

  // Buffer to store temporary strings:
  char * string_buffer = malloc( 250 * sizeof(char) ) ;

  // Secondary buffer to store temporary strings:
  char * aux_string_buffer = malloc( 250 * sizeof(char) ) ;

   /*
   * Used for tuples, as the same variable name cannot be used in different case
   * blocks:
   *
   */
  ETERM * res_array[5] ;

  // The term corresponding to the final result of a function call:
  ETERM * res_term ;


  GSM_Error gammu_error ;

  start_gammu( gammu_fsm ) ;


  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a single term is expected hence read)
   *
   */
  while ( read_command( buffer ) > 0 )
  {

	//LOG_TRACE( "New command received." ) ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;


	// Array containing, in-order, the (param_count) transmitted parameters:
	ETERM ** parameters = NULL ;

	ETERM * call_term = get_function_information( buffer, &current_fun_id,
	  &param_count, &parameters ) ;

	/*
	LOG_DEBUG( "Function identifier is %u, arity is %u.", current_fun_id,
	  param_count ) ;
	 */

	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{

	case GET_BACKEND_INFORMATION_0_ID:

		/* -spec get_backend_information() ->
		 *    { backend_type(), backend_version() }.
		 */

		LOG_DEBUG( "Executing get_backend_information/0." ) ;
		check_arity_is( 0, param_count, GET_BACKEND_INFORMATION_0_ID ) ;

		// Returning for example: { gammu, "1.40.0" }:

		res_array[0] = erl_mk_atom( "gammu" ) ;
		res_array[1] = erl_mk_string( GetGammuVersion() ) ;

		res_term = erl_mk_tuple( res_array, 2 ) ;

		write_term( buffer, res_term ) ;

		break ;


	case GET_DEVICE_NAME_0_ID:

		// -spec get_device_name() -> device_name().

		LOG_DEBUG( "Executing get_device_name/0." ) ;
		check_arity_is( 0, param_count, GET_DEVICE_NAME_0_ID ) ;

		const char * device_name = GSM_GetConfig( gammu_fsm, -1 )->Device ;

		write_as_binary( buffer, device_name ) ;

		break ;


	case GET_DEVICE_MANUFACTURER_0_ID:

		// -spec get_device_manufacturer() -> manufacturer_name().

		LOG_DEBUG( "Executing get_device_manufacturer/0." ) ;
		check_arity_is( 0, param_count, GET_DEVICE_MANUFACTURER_0_ID ) ;

		gammu_error = GSM_GetManufacturer( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;


	case GET_DEVICE_MODEL_0_ID:

		// -spec get_device_model() -> model_name().

		LOG_DEBUG( "Executing get_device_model/0." ) ;
		check_arity_is( 0, param_count, GET_DEVICE_MODEL_0_ID ) ;

		gammu_error = GSM_GetModel( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;


	case GET_FIRMWARE_INFORMATION_0_ID:

		/* -spec get_firmware_information() ->
		 *   { revision_text(), date_text(), revision_number() }.
		 */

		LOG_DEBUG( "Executing get_firmware_information/0." ) ;
		check_arity_is( 0, param_count, GET_FIRMWARE_INFORMATION_0_ID ) ;

		double rev_number ;

		gammu_error = GSM_GetFirmware( gammu_fsm, string_buffer,
		  aux_string_buffer, &rev_number ) ;

		check_gammu_error( gammu_error, gammu_fsm ) ;

		res_array[0] = make_bin_string( string_buffer ) ;
		res_array[1] = make_bin_string( aux_string_buffer ) ;
		res_array[2] = erl_mk_float( rev_number ) ;

		res_term = erl_mk_tuple( res_array, 3 ) ;

		write_term( buffer, res_term ) ;

		break ;


	case GET_IMEI_CODE_0_ID:

		// -spec get_imei_code() -> imei().

		LOG_DEBUG( "Executing get_imei_code/0." ) ;

		check_arity_is( 0, param_count, GET_IMEI_CODE_0_ID ) ;

		gammu_error = GSM_GetIMEI( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;


	case GET_HARDWARE_INFORMATION_0_ID:

		// -spec get_hardware_information() -> hardware_info().

		LOG_DEBUG( "Executing get_hardware_information/0." ) ;

		check_arity_is( 0, param_count, GET_HARDWARE_INFORMATION_0_ID ) ;

		gammu_error = GSM_GetHardware( gammu_fsm, string_buffer ) ;

		if ( gammu_error == ERR_NONE )
		{

		  write_as_binary( buffer, string_buffer ) ;

		}
		else
		{

		  /*
		   * Returning a string instead (convention here is that an exception is
		   * thrown by mobile.erl should a non-binary result be received):
		   *
		   */

		  int res = sprintf( string_buffer, "Gammu error:: %s",
			GSM_ErrorString( gammu_error ) ) ;

		  if ( res < 0 )
			raise_gammu_error( gammu_fsm, "Error reporting failed" ) ;

		  write_as_string( buffer, string_buffer ) ;

		}

		break ;


	case GET_IMSI_CODE_0_ID:

		// -spec get_imsi_code() -> imsi_code().

		LOG_DEBUG( "Executing get_imsi_code/0." ) ;

		check_arity_is( 0, param_count, GET_IMSI_CODE_0_ID ) ;

		gammu_error = GSM_GetSIMIMSI( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;


	case GET_SIGNAL_QUALITY_0_ID:

		/* -spec get_signal_quality() ->
		 *    { signal_strength(), signal_strength_percent(), error_rate() }.
		 */

		LOG_DEBUG( "Executing get_signal_quality/0." ) ;
		check_arity_is( 0, param_count, GET_SIGNAL_QUALITY_0_ID ) ;

		GSM_SignalQuality sq ;
		gammu_error = GSM_GetSignalQuality( gammu_fsm, &sq ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		res_array[0] = erl_mk_int( sq.SignalStrength ) ;
		res_array[1] = erl_mk_int( sq.SignalPercent ) ;
		res_array[2] = erl_mk_int( sq.BitErrorRate ) ;

		res_term = erl_mk_tuple( res_array, 3 ) ;

		write_term( buffer, res_term ) ;

		break ;


	case SEND_SMS_2_ID:

		/* -spec send_sms( message(), mobile_number() ) -> sms_id().
		 *
		 */

		LOG_DEBUG( "Executing send_sms/2." ) ;
		check_arity_is( 2, param_count, SEND_SMS_2_ID ) ;

		// Clean-up the struct:
		memset( &sms, 0, sizeof( sms ) ) ;

		char * message = get_parameter_as_binary( 1, parameters ) ;

		if ( message == NULL )
		  raise_gammu_error( gammu_fsm, "SMS message could not be obtained." ) ;

		EncodeUnicode( sms.Text, message, strlen( message ) ) ;

		// Message recipient:
		char * mobile_number = get_parameter_as_binary( 2, parameters ) ;

		if ( mobile_number == NULL )
		  raise_gammu_error( gammu_fsm, "SMS mobile number could not be obtained." ) ;

		EncodeUnicode( sms.Number, mobile_number, strlen( mobile_number ) ) ;

		// We want to submit message ("SMS for sending or in Outbox"):
		sms.PDU = SMS_Submit ;

		// No User Data Header, just a plain message:
		sms.UDH.Type = UDH_NoUDH ;

		// We used default coding for text:
		sms.Coding = SMS_Coding_Default_No_Compression ;

		// Class 1 message (normal):
		sms.Class = 1 ;

		// Sets the SMSC number in message:
		CopyUnicodeString( sms.SMSC.Number, device_smsc.Number ) ;

		// Resets it first, some phones might give instant response:
		sms_send_status = ERR_TIMEOUT ;

		// Finally:
		gammu_error = GSM_SendSMS( gammu_fsm, &sms ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		/* We do not have yet anything to return, but the callback will. */
		//write_as_XXX( buffer, ... ) ;

		/* However, using real devices (not the dummy one), we see that the
		 * callback is never triggered unless we poll explicitly from a network
		 * reply.
		 *
		 * Loops as long as the status is ERR_TIMEOUT:
		 *
		 */
		while ( ( ! shutdown_requested ) && ( sms_send_status == ERR_TIMEOUT ) )
		{

		  LOG_DEBUG( "Reading device..." ) ;

		  /* Expected to trigger sms_sending_callback/4 (true: wait for reply;
		   * number of read bytes ignored):
		   *
		   */
		  GSM_ReadDevice( gammu_fsm, true ) ;

		  /* Answer to be sent by the callback, just ensuring here we read the
		   * device until an answer is known.
		   *
		   * Loops as long as the status is ERR_TIMEOUT:
		   *
		   */

		}

		LOG_DEBUG( "Device read." ) ;

		erl_free( message ) ;
		erl_free( mobile_number ) ;

		break ;


	default:

	  // Hopefully no 'break' has been forgotten above!
	  raise_gammu_error( gammu_fsm, "Unknown function identifier: %u", current_fun_id ) ;

	}

	clean_up_command( call_term, parameters ) ;

  }


  free( string_buffer ) ;

  stop_gammu( gammu_fsm ) ;

  stop_seaplus_driver( buffer ) ;

}


void start_gammu( GSM_StateMachine * gammu_fsm )
{

  LOG_DEBUG( "Starting Gammu." ) ;

  // Registering our signal handler:
  signal( SIGINT, mobile_interrupt ) ;
  signal( SIGTERM, mobile_interrupt) ;

  GSM_Debug_Info * debug_info ;

  FILE * debug_file = NULL ;

  if ( enable_gammu_logging )
  {

	if ( log_file != NULL )
	{

	  LOG_DEBUG( "Directing Gammu logs to Seaplus ones." ) ;
	  debug_file = log_file ;

	}
	else
	{

	  LOG_DEBUG( "Gammu logs directed to standard error." ) ;
	  debug_file = stderr ;
	}

	debug_info = GSM_GetGlobalDebug() ;

	GSM_SetDebugFileDescriptor( debug_file, FALSE, debug_info ) ;

	GSM_SetDebugLevel( "textall", debug_info ) ;

  }
  else
  {

	LOG_DEBUG( "No Gammu logs requested." ) ;

  }


  if( enable_gammu_state_machine_logging )
  {

	if ( log_file != NULL )
	{

	  LOG_DEBUG( "Directing Gammu state machine logs to Seaplus ones." ) ;
	  debug_file = log_file ;

	}
	else
	{

	  LOG_DEBUG( "Gammu state machine logs directed to standard error." ) ;
	  debug_file = stderr ;

	}

	debug_info = GSM_GetDebug( gammu_fsm ) ;

	GSM_SetDebugGlobal( FALSE, debug_info ) ;

	GSM_SetDebugFileDescriptor( debug_file, FALSE, debug_info ) ;

	GSM_SetDebugLevel( "textall", debug_info ) ;

  }
  else
  {

	LOG_DEBUG( "No Gammu state machine logs requested." ) ;

  }

  INI_Section * iniConfig ;

  // Autodetect the configuration file (ex: ~/.gammurc):
  GSM_Error error = GSM_FindGammuRC( &iniConfig, NULL ) ;
  check_gammu_error( error, gammu_fsm ) ;

  // Read it:
  int read_section_count = 0 ;

  // To be populated from INI content:
  GSM_Config * config = GSM_GetConfig( gammu_fsm, read_section_count ) ;
  check_gammu_error( error, gammu_fsm ) ;

  error = GSM_ReadConfig( iniConfig, config, read_section_count ) ;
  check_gammu_error( error, gammu_fsm ) ;

  INI_Free( iniConfig ) ;

  // We care only about the first configuration:
  int section_id = 1 ;

  GSM_SetConfigNum( gammu_fsm, section_id ) ;
  check_gammu_error( error, gammu_fsm ) ;

  // Number of replies to await:
  int reply_count = 3 ;

  error = GSM_InitConnection( gammu_fsm, reply_count ) ;
  check_gammu_error( error, gammu_fsm ) ;

  // No user data:
  GSM_SetSendSMSStatusCallback( gammu_fsm, sms_sending_callback, NULL ) ;

  // We need to know SMSC number:
  device_smsc.Location = 1 ;
  error = GSM_GetSMSC( gammu_fsm, &device_smsc ) ;
  check_gammu_error( error, gammu_fsm ) ;

  if ( interrupt_buffer != NULL )
	raise_gammu_error( gammu_fsm, "Interrupt buffer already set." ) ;

  interrupt_buffer = (byte *) malloc( buffer_size ) ;

  if ( interrupt_buffer == NULL )
	raise_gammu_error( gammu_fsm, "Interrupt buffer allocation failed." ) ;

}


void check_gammu_error( GSM_Error error, GSM_StateMachine * gammu_fsm )
{

  if ( error != ERR_NONE )
	raise_gammu_error( gammu_fsm, "Gammu error: %s",
	  GSM_ErrorString( error ) ) ;

}


/* Raises specified error: reports it in logs, shutdown relevant phone services,
 * and halts.
 *
 */
void raise_gammu_error( GSM_StateMachine * gammu_fsm, const char * format, ... )
{

  if ( gammu_fsm != NULL )
  {

	if ( GSM_IsConnected( gammu_fsm ) )
	  GSM_TerminateConnection( gammu_fsm ) ;
  }

  // Uses Seaplus service, variadic-forwarding:

  va_list extra_args ;

  va_start( extra_args, format ) ;

  raise_error( format, extra_args ) ;

  // This clean-up will never happen:
  va_end( extra_args ) ;

}


void stop_gammu( GSM_StateMachine * gammu_fsm )
{

  LOG_DEBUG( "Stopping Gammu." ) ;

  if ( GSM_IsConnected( gammu_fsm ) )
  {

	GSM_Error error = GSM_TerminateConnection( gammu_fsm ) ;
	check_gammu_error( error, gammu_fsm ) ;

  }

  GSM_FreeStateMachine( gammu_fsm ) ;

}
