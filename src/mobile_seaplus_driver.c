

/*
 * C Seaplus driver in charge of converting, for each function exposed by the
 * 'mobile' service API, the Erlang parameters received from the port into
 * C variables that can be passed to the service functions, and to perform the
 * reciprocal operation on their results, so that they can be sent back to the
 * Erlang calling side.
 *
 */


// Generated by the Seaplus parse transform, based on mobile.erl:
#include "mobile_seaplus_api_mapping.h"


// Generic helpers to facilitate the writing of this C part of the bridge:
#include "seaplus.h"


// To access to the actual C implementation of the Gammu library:
#include "gammu.h"


// For exit:
#include <stdlib.h>

// For signal:
#include <signal.h>

// For memset:
#include <string.h>

// For va_start and friends:
#include <stdarg.h>



/* Apparently, when the callback set in SetSendSMSStatusCallback/3 is triggered,
   no information allows to relate a specific SMS that was sent to that callback
   (message reference is set by the carrier in the PDU that is received back).

   So, if sending a series of SMS in a row, we can only suppose that the
   callbacks triggered will be in-order (first callback corresponding to first
   SMS sent, etc.).

   Anyway, even with the dummy device, if performing two sendings in a row, the
   callback for the first will be triggered before the second is sent, so no
   problematic interleaving shall happen.

 */


/* The reference onto a SMS is supposed to be an unsigned char, but the
 * signature of the callback tells otherwise:
 *
 */
typedef int sms_tpmr ;

enum encoding { unicode_uncompressed=1,
				unicode_compressed,
				gsm_uncompressed,
				gsm_compressed,
				eight_bit } ;

// Forward declarations:

void start_gammu( GSM_StateMachine * gammu_fsm ) ;


void send_regular_sms( ETERM ** parameters,
  GSM_StateMachine * gammu_fsm ) ;


void send_multipart_sms( ETERM ** parameters,
  GSM_StateMachine * gammu_fsm ) ;



GSM_Coding_Type get_encoding( enum encoding e ) ;

void check_gammu_error( GSM_Error error, GSM_StateMachine * gammu_fsm ) ;

void raise_gammu_error( GSM_StateMachine * gammu_fsm,
  const char * format, ... ) ;

void stop_gammu( GSM_StateMachine * gammu_fsm ) ;



// Defined and used by Seaplus:
extern FILE * log_file ;

// If wanting to enable global debugging of Gammu in Seaplus logs:
bool enable_gammu_logging = true ;

// If wanting to enable FSM-level debugging of Gammu in Seaplus logs:
bool enable_gammu_state_machine_logging = false ;


// Typically for a sending:
typedef int status ;


// UNIX signal:
typedef int signal_reported ;


volatile bool shutdown_requested = false ;


// Tells whether the last SMS sending succeeded:
volatile status sms_send_status = false ;

GSM_Debug_Info * debug_info ;

GSM_SMSMessage sms ;

GSM_SMSC device_smsc ;


/*
 * An interrupt-specific buffer, not to interfere with the main one that could
 * be already in use. We believe that up to one interrupt can be active at any
 * time (not multiple ones).
 *
 */
byte * interrupt_buffer = NULL ;

ETERM * interrupt_array[ 2 ] ;

ETERM * interrupt_term = NULL ;


// Poor's man pseudo-mutex:
bool interrupt_in_use = false ;


/*
 * Callback triggered by Gammu after a request to send an SMS was issued.
 *
 * Returns a relevant term to the Erlang side.
 *
 */
void sms_sending_callback( GSM_StateMachine * gammu_fsm, status send_status,
  sms_tpmr ref, void * user_data )
{

  //LOG_DEBUG( "Entering callback." ) ;

  /* Not expected to ever happen, as the (Erlang) caller is blocked, waiting
   * for an answer not sent yet.
   *
   */
  if ( interrupt_in_use )
	raise_gammu_error( gammu_fsm, "Unexpected nested interrupt" ) ;

  interrupt_in_use = true ;

  if ( send_status == 0 )
  {

	// In case of success, returning { send_success, SMSRef }:

	sms_send_status = ERR_NONE ;

	LOG_DEBUG( "Received a success notification regarding the sending of "
	  "the SMS whose reference is #%i on device %s.", ref,
	  GSM_GetConfig( gammu_fsm, -1 )->Device ) ;

	interrupt_array[0] = erl_mk_atom( "send_success" ) ;

	if ( interrupt_array[0] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create success atom term" ) ;

	interrupt_array[1] = erl_mk_int( ref ) ;

	if ( interrupt_array[1] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create reference int term" ) ;

	interrupt_term = erl_mk_tuple( interrupt_array, 2 ) ;

	if( interrupt_term == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create success pair" ) ;

	write_term( interrupt_buffer, interrupt_term ) ;

  }
  else
  {

	// In case of failure, returning { send_failure, SMSRef }:

	sms_send_status = ERR_UNKNOWN ;

	LOG_WARNING( "Received a failure notification regarding the sending of "
	  "the SMS whose reference is #%i on device %s.", ref,
	  GSM_GetConfig( gammu_fsm, -1 )->Device ) ;

	interrupt_array[0] = erl_mk_atom( "send_failure" ) ;

	if ( interrupt_array[0] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create success failure term" ) ;

	interrupt_array[1] = erl_mk_int( ref ) ;

	if ( interrupt_array[1] == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create reference int term" ) ;

	interrupt_term = erl_mk_tuple( interrupt_array, 2 ) ;

	if( interrupt_term == NULL )
	  raise_gammu_error( gammu_fsm, "Failed to create failure pair" ) ;

	write_term( interrupt_buffer, interrupt_term ) ;

  }

  interrupt_in_use = false ;

  //LOG_DEBUG( "Leaving callback." ) ;

}


// Mobile-specific interrupt signal handler.
void mobile_interrupt( signal_reported sign )
{

  LOG_WARNING( "Signal #%i caught, shutting down Ceylan-Mobile.", sign ) ;

  signal( sign, SIG_IGN ) ;

  shutdown_requested = true ;

}


// No argumeter expected nor taken into account:
int main( int argc, char **argv )
{

  // Provided by the Seaplus library:
  byte * buffer = start_seaplus_driver() ;

  LOG_TRACE( "Driver started." ) ;

  // Gammu uses strings in the local encoding:
  GSM_InitLocales( NULL ) ;

  // Gammu is state-machine based:
  GSM_StateMachine * gammu_fsm = GSM_AllocStateMachine() ;

  if ( gammu_fsm == NULL )
	raise_gammu_error( gammu_fsm, "Unable to allocate Gammu state machine." ) ;

  // Pre-allocations:

  // Buffer to store temporary strings:
  char * string_buffer = malloc( 250 * sizeof(char) ) ;

  // Secondary buffer to store temporary strings:
  char * aux_string_buffer = malloc( 250 * sizeof(char) ) ;

   /*
   * Used for tuples, as the same variable name cannot be used in different case
   * blocks:
   *
   */
  ETERM * res_array[5] ;

  // The term corresponding to the final result of a function call:
  ETERM * res_term ;


  GSM_Error gammu_error ;

  start_gammu( gammu_fsm ) ;


  /* Reads a full command from (receive) buffer, based on its initial length:
   *
   * (a regular term is expected hence read)
   *
   */
  while ( read_command( buffer ) > 0 )
  {

	//LOG_TRACE( "New command received." ) ;

	/* Will be set to the corresponding Seaplus-defined function identifier (ex:
	 * whose value is FOO_1_ID):
	 *
	 */
	fun_id current_fun_id ;

	/* Will be set to the number of parameters obtained from Erlang for the
	 * function whose identifier has been transmitted:
	 *
	 */
	arity param_count ;


	// Array containing, in-order, the (param_count) transmitted parameters:
	ETERM ** parameters = NULL ;

	ETERM * call_term = get_function_information( buffer, &current_fun_id,
	  &param_count, &parameters ) ;

	/*
	LOG_DEBUG( "Function identifier is %u, arity is %u.", current_fun_id,
	  param_count ) ;
	 */

	// Now, taking care of the corresponding function call:
	switch( current_fun_id )
	{



	case GET_BACKEND_INFORMATION_0_ID:

		/* -spec get_backend_information() ->
		 *    { backend_type(), backend_version() }.
		 */

		LOG_DEBUG( "Executing get_backend_information/0." ) ;
		check_arity_is( 0, param_count, GET_BACKEND_INFORMATION_0_ID ) ;

		// Returning for example: { gammu, "1.40.0" }:

		res_array[0] = erl_mk_atom( "gammu" ) ;
		res_array[1] = erl_mk_string( GetGammuVersion() ) ;

		res_term = erl_mk_tuple( res_array, 2 ) ;

		write_term( buffer, res_term ) ;

		break ;



	case GET_DEVICE_NAME_0_ID:

		// -spec get_device_name() -> device_name().

		LOG_DEBUG( "Executing get_device_name/0." ) ;
		check_arity_is( 0, param_count, GET_DEVICE_NAME_0_ID ) ;

		const char * device_name = GSM_GetConfig( gammu_fsm, -1 )->Device ;

		write_as_binary( buffer, device_name ) ;

		break ;



	case GET_DEVICE_MANUFACTURER_0_ID:

		// -spec get_device_manufacturer() -> manufacturer_name().

		LOG_DEBUG( "Executing get_device_manufacturer/0." ) ;
		check_arity_is( 0, param_count, GET_DEVICE_MANUFACTURER_0_ID ) ;

		gammu_error = GSM_GetManufacturer( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;



	case GET_DEVICE_MODEL_0_ID:

		// -spec get_device_model() -> model_name().

		LOG_DEBUG( "Executing get_device_model/0." ) ;
		check_arity_is( 0, param_count, GET_DEVICE_MODEL_0_ID ) ;

		gammu_error = GSM_GetModel( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;



	case GET_FIRMWARE_INFORMATION_0_ID:

		/* -spec get_firmware_information() ->
		 *   { revision_text(), date_text(), revision_number() }.
		 */

		LOG_DEBUG( "Executing get_firmware_information/0." ) ;
		check_arity_is( 0, param_count, GET_FIRMWARE_INFORMATION_0_ID ) ;

		double rev_number ;

		gammu_error = GSM_GetFirmware( gammu_fsm, string_buffer,
		  aux_string_buffer, &rev_number ) ;

		check_gammu_error( gammu_error, gammu_fsm ) ;

		res_array[0] = make_bin_string( string_buffer ) ;
		res_array[1] = make_bin_string( aux_string_buffer ) ;
		res_array[2] = erl_mk_float( rev_number ) ;

		res_term = erl_mk_tuple( res_array, 3 ) ;

		write_term( buffer, res_term ) ;

		break ;



	case GET_IMEI_CODE_0_ID:

		// -spec get_imei_code() -> imei().

		LOG_DEBUG( "Executing get_imei_code/0." ) ;

		check_arity_is( 0, param_count, GET_IMEI_CODE_0_ID ) ;

		gammu_error = GSM_GetIMEI( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;



	case GET_HARDWARE_INFORMATION_0_ID:

		// -spec get_hardware_information() -> hardware_info().

		LOG_DEBUG( "Executing get_hardware_information/0." ) ;

		check_arity_is( 0, param_count, GET_HARDWARE_INFORMATION_0_ID ) ;

		gammu_error = GSM_GetHardware( gammu_fsm, string_buffer ) ;

		if ( gammu_error == ERR_NONE )
		{

		  write_as_binary( buffer, string_buffer ) ;

		}
		else
		{

		  /*
		   * Returning a string instead (convention here is that an exception is
		   * thrown by mobile.erl should a non-binary result be received):
		   *
		   */

		  int res = sprintf( string_buffer, "Gammu error: %s",
			GSM_ErrorString( gammu_error ) ) ;

		  if ( res < 0 )
			raise_gammu_error( gammu_fsm, "Error reporting failed" ) ;

		  write_as_string( buffer, string_buffer ) ;

		}

		break ;



	case GET_IMSI_CODE_0_ID:

		// -spec get_imsi_code() -> imsi_code().

		LOG_DEBUG( "Executing get_imsi_code/0." ) ;

		check_arity_is( 0, param_count, GET_IMSI_CODE_0_ID ) ;

		gammu_error = GSM_GetSIMIMSI( gammu_fsm, string_buffer ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		write_as_binary( buffer, string_buffer ) ;

		break ;



	case GET_SIGNAL_QUALITY_0_ID:

		/* -spec get_signal_quality() ->
		 *    { signal_strength(), signal_strength_percent(), error_rate() }.
		 */

		LOG_DEBUG( "Executing get_signal_quality/0." ) ;
		check_arity_is( 0, param_count, GET_SIGNAL_QUALITY_0_ID ) ;

		GSM_SignalQuality sq ;
		gammu_error = GSM_GetSignalQuality( gammu_fsm, &sq ) ;
		check_gammu_error( gammu_error, gammu_fsm ) ;

		res_array[0] = erl_mk_int( sq.SignalStrength ) ;
		res_array[1] = erl_mk_int( sq.SignalPercent ) ;
		res_array[2] = erl_mk_int( sq.BitErrorRate ) ;

		res_term = erl_mk_tuple( res_array, 3 ) ;

		write_term( buffer, res_term ) ;

		LOG_DEBUG( "get_signal_quality/0 executed." ) ;

		break ;



	case SEND_REGULAR_SMS_3_ID:

		/* -spec send_regular_sms( message(), recipient_number(), encoding() ) ->
		 *                        sms_id().
		 *
		 */

		LOG_DEBUG( "Executing send_regular_sms/3." ) ;
		check_arity_is( 3, param_count, SEND_REGULAR_SMS_3_ID ) ;

		send_regular_sms( parameters, gammu_fsm ) ;

		break ;



	case SEND_MULTIPART_SMS_2_ID:

		/* No SEND_MULTIPART_SMS_2_ID case: the Erlang part is to trigger only
		 * the SEND_MULTIPART_SMS_3_ID version.
		 *
		 */
		raise_error( "Unexpected call to driver-level send_multipart_sms/2." ) ;

		break ;


	case SEND_MULTIPART_SMS_3_ID:


	  /* -spec send_multipart_sms( message(), recipient_number(),
		 *                           encoding() ) -> sms_id().
		 *
		 */

		LOG_DEBUG( "Executing send_multipart_sms/3." ) ;
		check_arity_is( 3, param_count, SEND_MULTIPART_SMS_3_ID ) ;

		send_multipart_sms( parameters, gammu_fsm ) ;

		break ;



	case SEND_SMS_2_ID:
		/* No SEND_SMS_2_ID case: the Erlang part is to select the right version
		 * among the SEND_*_SMS_3_ID.
		 *
		 */
		raise_error( "Unexpected call to driver-level send_sms/2." ) ;

		break ;



	default:

		// Hopefully no 'break' has been forgotten above!
		raise_gammu_error( gammu_fsm, "Unknown function identifier: %u",
		  current_fun_id ) ;

	}

	clean_up_command( call_term, parameters ) ;

  }


  free( string_buffer ) ;

  stop_gammu( gammu_fsm ) ;

  stop_seaplus_driver( buffer ) ;

}


void start_gammu( GSM_StateMachine * gammu_fsm )
{

  LOG_DEBUG( "Starting Gammu." ) ;

  // Registering our signal handler:
  signal( SIGINT, mobile_interrupt ) ;
  signal( SIGTERM, mobile_interrupt) ;

  FILE * debug_file = NULL ;

  if ( enable_gammu_logging )
  {

	if ( log_file != NULL )
	{

	  LOG_DEBUG( "Directing Gammu logs to Seaplus ones." ) ;
	  debug_file = log_file ;

	}
	else
	{

	  LOG_DEBUG( "Gammu logs directed to standard error." ) ;
	  debug_file = stderr ;
	}

	debug_info = GSM_GetGlobalDebug() ;

	GSM_SetDebugFileDescriptor( debug_file, false, debug_info ) ;

	GSM_SetDebugLevel( "textall", debug_info ) ;

  }
  else
  {

	LOG_DEBUG( "No Gammu logs requested." ) ;

  }


  if( enable_gammu_state_machine_logging )
  {

	if ( log_file != NULL )
	{

	  LOG_DEBUG( "Directing Gammu state machine logs to Seaplus ones." ) ;
	  debug_file = log_file ;

	}
	else
	{

	  LOG_DEBUG( "Gammu state machine logs directed to standard error." ) ;
	  debug_file = stderr ;

	}

	debug_info = GSM_GetDebug( gammu_fsm ) ;

	GSM_SetDebugGlobal( false, debug_info ) ;

	GSM_SetDebugFileDescriptor( debug_file, false, debug_info ) ;

	GSM_SetDebugLevel( "textall", debug_info ) ;

  }
  else
  {

	LOG_DEBUG( "No Gammu state machine logs requested." ) ;

  }

  INI_Section * iniConfig ;

  // Autodetect the configuration file (ex: ~/.gammurc):
  GSM_Error error = GSM_FindGammuRC( &iniConfig, NULL ) ;
  check_gammu_error( error, gammu_fsm ) ;

  // Read it:
  int read_section_count = 0 ;

  // To be populated from INI content:
  GSM_Config * config = GSM_GetConfig( gammu_fsm, read_section_count ) ;
  check_gammu_error( error, gammu_fsm ) ;

  error = GSM_ReadConfig( iniConfig, config, read_section_count ) ;
  check_gammu_error( error, gammu_fsm ) ;

  INI_Free( iniConfig ) ;

  // We care only about the first configuration:
  int section_id = 1 ;

  GSM_SetConfigNum( gammu_fsm, section_id ) ;
  check_gammu_error( error, gammu_fsm ) ;

  // Number of replies to await:
  int reply_count = 3 ;

  error = GSM_InitConnection( gammu_fsm, reply_count ) ;
  check_gammu_error( error, gammu_fsm ) ;

  // No user data:
  GSM_SetSendSMSStatusCallback( gammu_fsm, sms_sending_callback, NULL ) ;

  // We need to know the SMSC number:
  device_smsc.Location = 1 ;
  error = GSM_GetSMSC( gammu_fsm, &device_smsc ) ;
  check_gammu_error( error, gammu_fsm ) ;

  if ( interrupt_buffer != NULL )
	raise_gammu_error( gammu_fsm, "Interrupt buffer already set." ) ;

  interrupt_buffer = (byte *) malloc( buffer_size ) ;

  if ( interrupt_buffer == NULL )
	raise_gammu_error( gammu_fsm, "Interrupt buffer allocation failed." ) ;

}


// Helpers defined to avoid variable name clashes in the function switch, and to factor code:


/* Sends a regular (single-part) SMS with specified encoding.
 *
 */
void send_regular_sms( ETERM ** parameters, GSM_StateMachine * gammu_fsm )
{

  char * message = get_parameter_as_binary( 1, parameters ) ;

  if ( message == NULL )
	raise_gammu_error( gammu_fsm,
	  "SMS message could not be obtained (regular)." ) ;

  // Clean-up the struct:
  memset( &sms, 0, sizeof( sms ) ) ;

  EncodeUnicode( sms.Text, message, strlen( message ) ) ;

  // Message recipient:
  char * recipient_number = get_parameter_as_binary( 2, parameters ) ;

  if ( recipient_number == NULL )
	raise_gammu_error( gammu_fsm,
	  "SMS recipient mobile number could not be obtained." ) ;

  EncodeUnicode( sms.Number, recipient_number, strlen( recipient_number ) ) ;

  // We want to submit message ("SMS for sending or in Outbox"):
  sms.PDU = SMS_Submit ;

  // No User Data Header, just a plain message:
  sms.UDH.Type = UDH_NoUDH ;

  sms.Coding = get_encoding( get_parameter_as_int( 3, parameters ) ) ;

  // Class 1 message (normal):
  sms.Class = 1 ;

  // Sets the SMSC number in message:
  CopyUnicodeString( sms.SMSC.Number, device_smsc.Number ) ;

  // Resets it first, some phones might give instant response:
  sms_send_status = ERR_TIMEOUT ;

  // Finally:
  GSM_Error gammu_error = GSM_SendSMS( gammu_fsm, &sms ) ;
  check_gammu_error( gammu_error, gammu_fsm ) ;

  /* We do not have yet anything to return, but the callback will. */
  //write_as_XXX( buffer, ... ) ;

  /* However, using real devices (not the dummy one), we see that the callback
   * is never triggered unless we poll explicitly from a network reply.
   *
   * Loops as long as the status is ERR_TIMEOUT:
   *
   */
  while ( ( ! shutdown_requested ) && ( sms_send_status == ERR_TIMEOUT ) )
  {

	LOG_DEBUG( "Reading device..." ) ;

	/* Expected to trigger sms_sending_callback/4 (true: wait for reply;
	 * number of read bytes ignored):
	 *
	 */
	GSM_ReadDevice( gammu_fsm, true ) ;

	/* Answer to be sent by the callback, just ensuring here we read the device
	 * until an answer is known.
	 *
	 * Loops as long as the status is ERR_TIMEOUT:
	 *
	 */

  }

  LOG_DEBUG( "Device read." ) ;

  erl_free( message ) ;
  erl_free( recipient_number ) ;

}



/* Sends a multipart SMS with specified encoding.
 *
 */
void send_multipart_sms( ETERM ** parameters,
  GSM_StateMachine * gammu_fsm )
{

  char * message = get_parameter_as_binary( 1, parameters ) ;

  if ( message == NULL )
	raise_gammu_error( gammu_fsm, "SMS message could not be obtained (multipart)." ) ;

   // Message recipient:
  char * recipient_number = get_parameter_as_binary( 2, parameters ) ;

  if ( recipient_number == NULL )
	raise_gammu_error( gammu_fsm,
	  "SMS recipient mobile number could not be obtained." ) ;

  unsigned int buf_size = ( strlen( message ) + 1 ) * 2 ;

  // To store message as Unicode:
  byte * msg_buffer = (byte *) malloc( buf_size ) ;

  if ( msg_buffer == NULL )
	raise_error( "Multipart message buffer could not be allocated." ) ;

  GSM_MultiPartSMSInfo SMSInfo ;
  GSM_ClearMultiPartSMSInfo( &SMSInfo ) ;

  // Class 1 message (normal):
  SMSInfo.Class = 1 ;

  // A message will consist of one part:
  SMSInfo.EntriesNum = 1 ;

  // No Unicode:
  SMSInfo.UnicodeCoding = false ;

  // This part has for type 'long text':
  SMSInfo.Entries[0].ID = SMS_ConcatenatedTextLong ;

  // Encode message text:
  EncodeUnicode( msg_buffer, message, strlen( message ) ) ;

  SMSInfo.Entries[0].Buffer = msg_buffer ;

  LOG_DEBUG( "Message once encoded in UCS-2: '%s'.",
	DecodeUnicodeConsole( SMSInfo.Entries[0].Buffer ) ) ;

  GSM_MultiSMSMessage MultiSMS ;

  // Encode message into PDU parts:
  GSM_Error gammu_error = GSM_EncodeMultiPartSMS( debug_info, &SMSInfo,
	&MultiSMS ) ;

  check_gammu_error( gammu_error, gammu_fsm ) ;

  size_t recipient_number_len = strlen( recipient_number ) ;


  // Now sending the message parts:
  for ( unsigned int i = 0; i < MultiSMS.Number; i++)
  {

	LOG_DEBUG( "Sending SMS part %i/%i", i+1, MultiSMS.Number ) ;

	// Sets the SMSC number in the current SMS:
	CopyUnicodeString( MultiSMS.SMS[i].SMSC.Number, device_smsc.Number ) ;

	// Encodes the recipient number:
	EncodeUnicode( MultiSMS.SMS[i].Number, recipient_number,
	  recipient_number_len ) ;

	// We want to submit message:
	MultiSMS.SMS[i].PDU = SMS_Submit ;

	/*
	 * Sets flag before callind SendSMS, as some phones might give instant
	 * response:
	 */
	sms_send_status = ERR_TIMEOUT ;

	// Send this message:
	gammu_error = GSM_SendSMS( gammu_fsm, &MultiSMS.SMS[i] ) ;
	check_gammu_error( gammu_error, gammu_fsm ) ;

	/* We do not have yet anything to return, but the callback will. */
	//write_as_XXX( buffer, ... ) ;

	/* However, using real devices (not the dummy one), we see that the callback
	 * is never triggered unless we poll explicitly from a network reply.
	 *
	 * Loops as long as the status is ERR_TIMEOUT:
	 *
	 */
	while ( ( ! shutdown_requested ) && ( sms_send_status == ERR_TIMEOUT ) )
	{

	  LOG_DEBUG( "Reading device..." ) ;

	  /* Expected to trigger sms_sending_callback/4 (true: wait for reply;
	   * number of read bytes ignored):
	   *
	   */
	  GSM_ReadDevice( gammu_fsm, true ) ;

	  /* Answer to be sent by the callback, just ensuring here we read the
	   * device until an answer is known.
	   *
	   */

	}

	LOG_DEBUG( "Device read." ) ;

  }

  free( msg_buffer ) ;

}


GSM_Coding_Type get_encoding( enum encoding e )
{

  // Actually the two enums matches, but we prefer checking:
  switch( e )
  {

  case unicode_uncompressed:
	return SMS_Coding_Unicode_No_Compression ;
	break ;

  case unicode_compressed:
	return SMS_Coding_Unicode_Compression ;
	break ;

  case gsm_uncompressed:
	return SMS_Coding_Default_No_Compression ;
	break ;

  case gsm_compressed:
	return SMS_Coding_Default_Compression ;
	break ;

  case eight_bit:
	return SMS_Coding_8bit ;
	break ;

  default:
	raise_error( "Unexpected encoding: %i", e ) ;
	break ;

  }

  // As the compiler is not smart:
  //raise_error( "Unexpected encoding: %i", e ) ;
  return 0 ;

}



void check_gammu_error( GSM_Error error, GSM_StateMachine * gammu_fsm )
{

  if ( error != ERR_NONE )
	raise_gammu_error( gammu_fsm, "Gammu error: %s",
	  GSM_ErrorString( error ) ) ;

}



/* Raises specified error: reports it in logs, shutdown relevant phone services,
 * and halts.
 *
 */
void raise_gammu_error( GSM_StateMachine * gammu_fsm, const char * format, ... )
{

  if ( gammu_fsm != NULL )
  {

	if ( GSM_IsConnected( gammu_fsm ) )
	  GSM_TerminateConnection( gammu_fsm ) ;
  }

  // Uses Seaplus service, variadic-forwarding:

  va_list extra_args ;

  va_start( extra_args, format ) ;

  raise_error( format, extra_args ) ;

  // This clean-up will never happen:
  va_end( extra_args ) ;

}


void stop_gammu( GSM_StateMachine * gammu_fsm )
{

  LOG_DEBUG( "Stopping Gammu." ) ;

  if ( GSM_IsConnected( gammu_fsm ) )
  {

	GSM_Error error = GSM_TerminateConnection( gammu_fsm ) ;
	check_gammu_error( error, gammu_fsm ) ;

  }

  GSM_FreeStateMachine( gammu_fsm ) ;

}
